package com.saga.serialization;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

/**
 * 
 * @author Sathish K Ganga
 * 
 *         SERIALIZATION: The process of saving state of object to a file,
 *         strictly speaking the process of converting an object from java
 *         supported form to file supported OR network supported form is called
 *         serialization.
 * 
 *         DESERIALIZATION: The process of converting file supported OR network
 *         supported form to java supported form is called deserialization.
 * 
 * 
 */

public class SerializationDemo1 implements Serializable {
	/**
	 * serialVersionUID:
	 * 
	 * -> Sender and receiver need not be same. -> Both sender and receiver need
	 * not be from same location. -> Sender and receiver need not to use same
	 * machine (Sender may use Linux while receiver using Windows). In
	 * serialization and deserialization '.class' file should be available on
	 * the sender machine and receiver machine at the beginning only. Just state
	 * of the object will be travelling from sender to receiver. At the time of
	 * serialization for every object, sender side JVM will save one generated
	 * unique identifier based on '.class' file. This is called
	 * serialversionUID.
	 * 
	 * > There are several problems if we depend on default SerialversionUID
	 * generated by JVM. Example: Suppose sender is using UNIX based 1.6 version
	 * JVM and generated UID - 101 If receiver is using WINDOWS based 1.8
	 * version JVM then there is no guarantee in generating same UID - 101 In
	 * such case if any mismatch happens, run time exception
	 * 'InvalidClassExceptio' appears.
	 * 
	 * Hence the problems are, > Both sender and receiver should use same JVM
	 * with respect to vendor and version. > Both sender and receiver should use
	 * same .class file version. > Performance problem: Internally JVM may use
	 * complex algorithm to generate UID.
	 * 
	 ** To overcome these problems, don't give chance to JVM to generate UID.
	 * Configure own UID. Example: private static final long serialversionUID =
	 * 1L;
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * TRANSIENT keyword: It is a modifier which is applicable ONLY FOR
	 * VARIABLES. At the time of serialization if we don't want any particular
	 * variable due to security reasons/constraints, such type of variable to be
	 * declared transient. > At the time of serialization, JVM ignores the
	 * original value of transient variable and saves default value of the
	 * variable. > Static variable will not participate in serialization as it
	 * is not object level variable. Hence there is no use of declaring static
	 * variable as transient. > Similarly, combining final keyword with
	 * transient is tricky. JVM won't save default value of variable as expected
	 * with transient and it depends on the declaration of the variable. In
	 * general final variables are assigned with value during compile time only.
	 * Hence the value can not be changed. Hence it doesn't serve the purpose of
	 * transient.
	 */
	int nonTransientVar = 10;
	transient int transientVar = 20;

	public static void main(String[] args) throws IOException,
			ClassNotFoundException {
		SerializationExampleClass1 obj = new SerializationExampleClass1();
		// Write SerializationDemo1 object to a file named 'test.txt'
		obj.serialize(new SerializationDemo1(), "Test.txt");
		// Read SerializationDemo1 object from a file named 'test.txt'
		obj.deSerialize("Test.txt");
	}
}

class SerializationExampleClass1 {

	// Classes used for serialization: FileOutputStream, ObjectOutputStream
	void serialize(SerializationDemo1 objToSerialize, String fileName)
			throws IOException {
		FileOutputStream fos = new FileOutputStream(fileName);
		@SuppressWarnings("resource")
		ObjectOutputStream oos = new ObjectOutputStream(fos);
		oos.writeObject(objToSerialize);
	}

	// Classes used for deserialization: FileInputStream, ObjectInputStream
	void deSerialize(String fileName) throws IOException,
			ClassNotFoundException {
		FileInputStream fis = new FileInputStream(fileName);
		@SuppressWarnings("resource")
		ObjectInputStream ois = new ObjectInputStream(fis);
		SerializationDemo1 deSerializedObj = (SerializationDemo1) ois
				.readObject();

		System.out.println("Non-transient var value = "
				+ deSerializedObj.nonTransientVar + " ..."
				+ " Transient var value = " + deSerializedObj.transientVar);
	}
}
